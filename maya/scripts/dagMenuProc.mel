// Copyright (C) 1997-2010 Autodesk, Inc., and/or its licensors.
// All rights reserved.
//
// The coded instructions, statements, computer programs, and/or related
// material (collectively the "Data") in these files contain unpublished
// information proprietary to Autodesk, Inc. ("Autodesk") and/or its licensors,
// which is protected by U.S. and Canadian federal copyright law and by
// international treaties.
//
// The Data is provided for use exclusively by You. You have the right to use,
// modify, and incorporate this Data into other products for purposes authorized 
// by the Autodesk software license agreement, without fee.
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND. AUTODESK
// DOES NOT MAKE AND HEREBY DISCLAIMS ANY EXPRESS OR IMPLIED WARRANTIES
// INCLUDING, BUT NOT LIMITED TO, THE WARRANTIES OF NON-INFRINGEMENT,
// MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, OR ARISING FROM A COURSE 
// OF DEALING, USAGE, OR TRADE PRACTICE. IN NO EVENT WILL AUTODESK AND/OR ITS
// LICENSORS BE LIABLE FOR ANY LOST REVENUES, DATA, OR PROFITS, OR SPECIAL,
// DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES, EVEN IF AUTODESK AND/OR ITS
// LICENSORS HAS BEEN ADVISED OF THE POSSIBILITY OR PROBABILITY OF SUCH DAMAGES.

//
//  Creation Date:  Dec 3, 1996
//
//
//  Description:
//      This script describes the contents of the context sensitive menus.
//
//  Input Arguments:
//      None.
//
//  Return Value:
//      None.
//

global proc maintainActiveChangeSelectMode( string $item )
{
	hilite -unHilite $item; 

	int $aa = `selectPref -q -affectsActive`;
	if (1 == $aa)
		selectPref -affectsActive 0;

	changeSelectMode -object; 

	if (1 == $aa)
		selectPref -affectsActive 1;
}

proc optionalDagMenuProc( string $parent, string $item )
{
	// Look at the shape child of this object
	//
	string $object[] = `listRelatives -path -s $item`;

	string $shape = "";
	int $gotVisible = 0;

	if( size($object) < 1 ) return;

	for( $i=0; $i<size($object); $i+=1) {
		if( (0 == getAttr($object[$i] + ".io")) &&
			getAttr($object[$i] + ".v") ) {
			$shape = $object[$i];
			$gotVisible = 1;
			break;
		}
	}

	if( !$gotVisible ) {
		for( $i=0; $i<size($object); $i+=1) {
			if( 0 == getAttr($object[$i] + ".io")) {
				$shape = $object[$i];
				break;
			}
		}
	}

	if( "" != $shape ) {
		string $nt = `nodeType $shape`;
		switch( $nt ) {
		  case "subdiv":
			subdOptionalDagMenuProc( $parent, $item );
			menuItem -d true; 
			break;

		  default:
			// Check to make sure we have a kPlugin prefix
			string $apiNt = `nodeType -api $shape`;
			if ( startsWith( $apiNt, "kPlugin" ) ) {
				string $nodeMenuCommand = $nt + "DagMenuProc";
				string $nodeMenuCommandWithArgs = $nodeMenuCommand + "(\"" + $parent + "\" , \"" + $item + "\" )";
				if ( exists( $nodeMenuCommand ) ) {
				   eval( $nodeMenuCommandWithArgs );
				}
			}
			break;
		}
	}
}

proc int objectIsTrimmed(string $item)
// Return true if this is a trimmed surface
{
	string $command = ("getAttr -size " + $item + ".trimFace");
	int $trimCount = eval($command);

	return ($trimCount != 0);
}


proc string getControlledHandle(string $item)
{
	string $handle;
	if (size(`ls ($item+".ikBlend")`)) {
		string $connHandles[] =
			`listConnections -type ikHandle ($item+".ikBlend")`;
		if (size($connHandles)) {
			$handle = $connHandles[0];
		}
	}
	return $handle;
}

proc int isIKcontroller(string $item)
{
	string $handle = getControlledHandle($item);
	return (size($handle) > 0);
}

proc
createFBIKmenuItems(string $parent,
					string $item,
					string $ikReachModeLocation,
					string $keyBodyPartLocation,
					string $keyAllLocation,
					string $keySelectedLocation)
{
	string $reachKeyingMode = (uiRes("m_dagMenuProc.kReachMode"));
	string $reachKeyingModeIK = (uiRes("m_dagMenuProc.kIkReachMode"));
	string $reachKeyingModeFK = (uiRes("m_dagMenuProc.kFkReachMode"));
	string $reachKeyingModeSimple = (uiRes("m_dagMenuProc.kSimpleeachMode"));
	if (!`optionVar -exists fbikKeyOption`) {
	    //3 == simple key
		optionVar -intValue fbikKeyOption 3;    
	}
	int $rkm = `optionVar -q fbikKeyOption`;
	switch ($rkm)
	{
		case 1:
			$reachKeyingMode = $reachKeyingModeIK;
			break;
		case 2:
			$reachKeyingMode = $reachKeyingModeFK;
			break;
		case 3:
			$reachKeyingMode = $reachKeyingModeSimple;
			break;
	}	

	menuItem -rp $ikReachModeLocation -label $reachKeyingMode
		-subMenu true
		-annotation (uiRes("m_dagMenuProc.kDetermineHowAnnot")) ;

		menuItem -rp "S" -label (uiRes("m_dagMenuProc.kIK")) 
			-command FBIKReachKeyingOptionIK;

		menuItem -rp "N" -label (uiRes("m_dagMenuProc.kFK")) 
			-command FBIKReachKeyingOptionFK;

		menuItem -rp "E" -label (uiRes("m_dagMenuProc.kSimpleNoReach")) 
			-command FBIKReachKeyingOptionSimple;

	setParent -m $parent;
	
	string $bodyPartKeyingModeStr;
	int $bodyPartKeyingMode = 1; // 1 == full body
	if (`optionVar -exists keyFullBody`) {
	    
		$bodyPartKeyingMode = `optionVar -query keyFullBody`;    
	}		
	else {
	    optionVar -intValue keyFullBody 1;
	}		
	
	if($bodyPartKeyingMode == 1) { //full body
	    menuItem -label (uiRes("m_dagMenuProc.kKeyAllSel")) 
		    -echoCommand true
		    -c ("optionVar -intValue keyFullBody 1; fbikDoSelectionChanged();headsUpDisplay -refresh HUDFbikKeyingMode;")
		    -rp $keyAllLocation
		    keyAllItem;
    }
    else {
	    menuItem -label (uiRes("m_dagMenuProc.kKeyAll")) 
		    -echoCommand true
		    -c ("optionVar -intValue keyFullBody 1; fbikDoSelectionChanged();headsUpDisplay -refresh HUDFbikKeyingMode;")
		    -rp $keyAllLocation
		    keyAllItem;
    }
	
	if($bodyPartKeyingMode == 2) { //body part
	    menuItem -label (uiRes("m_dagMenuProc.kKeyBodyPartSel")) 
		    -echoCommand true
		    -c ("optionVar -intValue keyFullBody 2; fbikDoSelectionChanged();headsUpDisplay -refresh HUDFbikKeyingMode;")
		    -rp $keyBodyPartLocation
		    keyBodyPartItem;
    }
    else {
	    menuItem -label (uiRes("m_dagMenuProc.kKeyBodyPart")) 
		    -echoCommand true
		    -c ("optionVar -intValue keyFullBody 2; fbikDoSelectionChanged();headsUpDisplay -refresh HUDFbikKeyingMode;")
		    -rp $keyBodyPartLocation
		    keyBodyPartItem;
    }
	
	if($bodyPartKeyingMode == 3) { //key selected
	    menuItem -label (uiRes("m_dagMenuProc.kKeySelectedSel")) 
		    -echoCommand true
		    -c ("optionVar -intValue keyFullBody 3; fbikDoSelectionChanged();headsUpDisplay -refresh HUDFbikKeyingMode;")
		    -rp $keySelectedLocation
		    keySelectedItem;
	}
	else {
	    menuItem -label (uiRes("m_dagMenuProc.kKeySelected")) 
		    -echoCommand true
		    -c ("optionVar -intValue keyFullBody 3; fbikDoSelectionChanged();headsUpDisplay -refresh HUDFbikKeyingMode;")
		    -rp $keySelectedLocation
		    keySelectedItem;
    }		    
}

// returns true if item was added to quadrant
proc int checkForSkinInfluenceItem(string $item, string $quadrant)
{
    int $quadFilled = 0;
	int $isJoint = (nodeType($item) == "joint");
	
	// Check if the current context is the skinPaint context 
	// and the the joint is connected to a skinCluster
	//
	string  $currContext = `currentCtx`;
	string  $currTool    = "";
	if(`contextInfo -ex $currContext`) {
		$currTool = `contextInfo -c $currContext`;
	}
	string $paintWeights = (uiRes("m_dagMenuProc.kPaintWeights"));
	if ( $currTool == "artAttrSkin" ) {
		string $whichTool = `artAttrCtx -q -whichTool $currContext`;
		if ( $whichTool == "skinWeights" )  {
			string $connL[] = `listConnections ($item+".worldMatrix")`;
			string $conn;
			for($conn in $connL) {
				if (`nodeType $conn` == "skinCluster")
				{	
					// select the surface (not the joint) and set
					// the joint as the current influence
					//
					string $currSel[] = `ls -sl`;
					string $currSelString;
					if (size($currSel) > 0) {
						string $currObj;
						$currSelString = "select -r ";
						for ($currObj in $currSel) {
							$currSelString += ($currObj+" ");
						}
					}
					menuItem -label $paintWeights 
						-echoCommand true
						-c ($currSelString+"; setSmoothSkinInfluence " + $item)
						-rp $quadrant
						paintWeightItem;
                    $quadFilled = 1;
					break;
				}
			}
		}
	}		// menu for skinCluster paint
	// Check if the current context is the clusterPaint context 
	// and the the joint is connected to a jointCluster
	//
	else if ( $isJoint && ($currTool == "artAttr") ) {
		string $whichTool = `artAttrCtx -q -whichTool $currContext`;
		if ( $whichTool == "general" )  {
			string $connL[] = `listConnections ($item+".worldMatrix")`;
			string $conn;
			for($conn in $connL) {
				if (`nodeType $conn` == "jointCluster")
				{
					string $artCommand = "artAttrCtx" ;
					string $attribute = "cluster." + $conn +  ".weights" ;
					menuItem -label $paintWeights 
						-echoCommand true
						// the following command doesnot update the UI hence we use the next one
						//-c ("artAttrCtx -e -pas \"cluster." + $conn +  ".weights\" `currentCtx`")
						-c ("artSetToolAndSelectAttr( \"" + $artCommand + "\", \"" + $attribute + "\" )")
						-rp "N"
						paintWeightItem;
					break;
				}
			}
		}
	}
	// menu for joint-set paint
	// Check if the current context is the setPaint context 
	// and the the joint is connected to a objectSet via jointCluster
	//
	else if ( $isJoint && ($currTool == "artSetPaint") ) {
		string $connL[] = `listConnections ($item+".worldMatrix")`;
		string $conn;
		for($conn in $connL) {
			if (`nodeType $conn` == "jointCluster") {	
				string $connS[] = `listConnections ($conn+".message")`;
				for($set in $connS) {
					if (`nodeType $set` == "objectSet") {
						menuItem -label (uiRes("m_dagMenuProc.kPaintSetMembership")) 
							-echoCommand true
							// the following command doesnot update the UI hence we use the next one
							//-c ("artSetPaintCtx -e -settomodify " + $set + " `currentCtx`")
							-c ("artSetPaintSelectSet( \"" + $set + "\" )")
							-rp "N"
							paintWeightItem;
						break;
					}
				}
			}
		}
	}
    return $quadFilled;
}

global proc string[] objectSelectMasks(string $item)
// Returns the component selection masks that apply to this object
{
	string $maskList[];
	string $shape = $item;
	int $i;

	// Look at the shape child of this object
	//
	string $object[] = `listRelatives -path -s $item`;

	int $gotVisible = 0;

	for ($i = 0; $i < size($object); ++$i) {
		if( (0 == getAttr($object[$i] + ".io")) &&
			getAttr($object[$i] + ".v") ) {
			$shape = $object[$i];
			$gotVisible = 1;
			break;
		}
	}

	if( !$gotVisible ) {
		for ($i = 0; $i < size($object); ++$i)
		{
			if (getAttr($object[$i] + ".io") == 0)
			{
				$shape = $object[$i];
				break;
			}
		}
	}

	string $nt = `nodeType $shape`;

	switch ($nt) {
		case "lattice":
			$maskList[0] = "latticePoint";
			break;	
		case "locator":
			$maskList[0] = "locator";
			break;	
		case "nurbsCurve":
			$maskList[0] = "curveParameterPoint";
			$maskList[1] = "controlVertex";
			$maskList[2] = "editPoint";
			$maskList[3] = "hull";
			break;
		case "bezierCurve":
			$maskList[0] = "curveParameterPoint";
			$maskList[1] = "bezierAnchor";
			$maskList[2] = "editPoint";
			$maskList[3] = "hull";
			break;
		case "nurbsSurface":
			$maskList[0] = "isoparm";
			$maskList[1] = "controlVertex";
			$maskList[2] = "surfaceParameterPoint";
			$maskList[3] = "hull";
			$maskList[4] = "surfaceFace";
			$maskList[5] = "surfaceUV"; 
			if (objectIsTrimmed($shape)) {
				$maskList[6] = "surfaceEdge";
			}
			break;
		case "mesh":
			$maskList[0] = "edge";
			$maskList[1] = "vertex";
			$maskList[2] = "facet";
			$maskList[3] = "puv";
			$maskList[4] = "pvf";
			$maskList[5] = "meshComponents";
			break;
		case "joint":
			$maskList[0] = "joint";		// special case
			break;
		case "ikHandle":
			$maskList[0] = "ikHandle";	// special case
			break;
		case "hikEffector":
		// fall through
		case "hikFloorContactMarker":
			$maskList[0] = "hikEffector";	// special case
			break;
		case "particle":
			$maskList[0] = "particle";	// only one choice
			break;
		case "nParticle":
			$maskList[0] = "particle";	// only one choice
			break;
		case "spring":
			$maskList[0] = "springComponent";	// only one choice
			break;
		case "subdiv":
 			$maskList[0] = "subdivMeshPoint";	
 			$maskList[1] = "subdivMeshEdge";	
 			$maskList[2] = "subdivMeshFace";	
 			$maskList[3] = "subdivMeshUV";	
			break;
	}

	if (isIKcontroller($item)) {
		$maskList[size($maskList)] = "ikfkHandle";
	}

	return $maskList;
}


global proc string dagMenuProc_selectionMask_melToUI( string $mel )
{
	string $result = $mel; 
 
	switch ($mel) 
	{
		case "latticePoint":
			$result = (uiRes("m_dagMenuProc.kLatticePoint"));
			break;
		case "locator":
			$result = (uiRes("m_dagMenuProc.kLocator"));
			break;		 
		case "bezierAnchor":
			$result = (uiRes("m_dagMenuProc.kBezierAnchor"));
			break;
		case "controlVertex":
			$result = (uiRes("m_dagMenuProc.kControlVertex"));
			break;
		case "editPoint":
			$result = (uiRes("m_dagMenuProc.kEditPoint"));
			break;
		case "hull":
			$result = (uiRes("m_dagMenuProc.kHull"));
			break;
		case "isoparm":
			$result = (uiRes("m_dagMenuProc.kIsoparm"));
			break;	 	 
		case "subdivMeshEdge":
			// fall through
		case "edge":
			$result = (uiRes("m_dagMenuProc.kEdge"));
			break;
		case "subdivMeshPoint":
			// fall through
		case "vertex":
			$result = (uiRes("m_dagMenuProc.kVertex"));
			break;
		case "joint":		
			$result = (uiRes("m_dagMenuProc.kJoint"));
			break;
		case "ikHandle":	
			$result = (uiRes("m_dagMenuProc.kIkHandle"));
			break;
		case "hikEffector":	
			$result = (uiRes("m_dagMenuProc.kHikEffector"));
			break;	 
		case "ikfkHandle":
			$result = (uiRes("m_dagMenuProc.kIkfkHandle"));
			break;
		case "surfaceUV":
			$result = (uiRes("m_dagMenuProc.kSurfaceUV"));
			break;
		case "surfaceParameterPoint":
			$result = (uiRes("m_dagMenuProc.kSurfacePoint"));
			break;	
		case "curveParameterPoint":
			$result = (uiRes("m_dagMenuProc.kCurvePoint"));
			break;
		case "surfaceEdge":
			$result = (uiRes("m_dagMenuProc.kTrimEdge"));
			break;
		case "surfaceFace":
			$result = (uiRes("m_dagMenuProc.kSurfacePatch"));
			break;
		case "subdivMeshUV":
			// fall through
		case "puv":
			$result = (uiRes("m_dagMenuProc.kUV"));
			break;
		case "subdivMeshFace":
			// fall through
		case "facet":
			$result = (uiRes("m_dagMenuProc.kFace"));
			break;	
		case "pvf":
			$result = (uiRes("m_dagMenuProc.kVertexFace"));
			break;
		case "nParticle":
		case "particle":
			$result = (uiRes("m_dagMenuProc.kParticle"));
			break;
		case "springComponent":
			$result = (uiRes("m_dagMenuProc.kSpring"));
			break;	 	 
		case "meshComponents":
			$result = (uiRes("m_dagMenuProc.kMultiComp"));
			break;	 	 
		default:
			uiToMelMsg( "dagMenuProc_selectionMask_melToUI", $mel, 1 );
			break;
	}

	return $result;		 	 
}

global proc int isRadialPositionUsed(string $radialPositionUsed[],string $position)
{
    for($pos in $radialPositionUsed)
    {
        if($pos == $position)
            return 1;
    }
    return 0;
}

global proc populateMMForPaintSkinWeights(string $item,string $radialPositionUsed[])
{
    // Check if the current context is the skinPaint context
	// and the the joint is connected to a skinCluster
	//		
	
	string  $currContext = `currentCtx`;	
	if ( $currContext == "artAttrSkinContext" )
	{
		string $whichTool = `artAttrCtx -q -whichTool $currContext`;
		if ( $whichTool == "skinWeights" )
		{								
			
			if (`attributeQuery -n $item -ex liw`) 
		    {
		    
			    menuItem -l (uiRes("m_dagMenuProc.kPaintPickValue"))
				    -echoCommand true
				    -c "artAttrCtx -e -pickValue `currentCtx`"
				    -rp "S";				
    				
			    $radialPositionUsed[size($radialPositionUsed)] = "S";
		
		    
		        string $cmd = "artSkinLockInfPassedIn " + $item + " ";
		        if ( `getAttr ( $item + ".liw" )` == 0 )
			    {
			        $cmd += "1";
				    menuItem -l (uiRes("m_dagMenuProc.kDagMenuLockInfluence"))
					    -echoCommand true
					    -c $cmd
					    -rp "NW";
			    }
			    else
			    {
			        $cmd += "0";
				    menuItem -l (uiRes("m_dagMenuProc.kDagMenuUnlockInfluence"))
					    -echoCommand true
					    -c $cmd
					    -rp "NW";
			    }
			    $radialPositionUsed[size($radialPositionUsed)] = "NW";
			
						
			    if ( `getAttr ($item + ".displayHandle")` == 0)
			    {
				    menuItem -l (uiRes("m_dagMenuProc.kShowDisplayHandle"))
					    -echoCommand true
					    -c (" setAttr " + $item + ".displayHandle 1" )
					    -rp "W";
			    }
			    else
			    {
				    menuItem -l (uiRes("m_dagMenuProc.kHideDisplayHandle"))
					    -echoCommand true
					    -c (" setAttr " + $item + ".displayHandle 0" )
					    -rp "W";
			    }
			
			    $radialPositionUsed[size($radialPositionUsed)] = "W";
			
			    if ( `getAttr ( $item + ".displayLocalAxis" )` == 0 )
			    {
				    menuItem -l (uiRes("m_dagMenuProc.kDisplayLocalAxis"))
					    -echoCommand true
					    -c (" setAttr " + $item + ".displayLocalAxis 1" )
					    -rp "SW";
			    }
			    else
			    {
				    menuItem -l (uiRes("m_dagMenuProc.kHideLocalAxis"))
					    -echoCommand true
					    -c (" setAttr " + $item + ".displayLocalAxis 0" )
					    -rp "SW";
			    }						
			    $radialPositionUsed[size($radialPositionUsed)] = "SW";

                string $selectVertCmd;
            
                $selectVertCmd = "artSkinSelectVerticesForInfluence " + $item + " 0 0 ";
                        
			    menuItem -l (uiRes("m_dagMenuProc.kSelectAffectedVertices"))
				    -echoCommand true
				    -c $selectVertCmd
				    -rp "NE";
    				
			    $radialPositionUsed[size($radialPositionUsed)] = "NE";

            
                string $addSelectedVerticesCmd = "artSkinSelectVerticesForInfluence " + $item + " 1 0";
			    menuItem -l (uiRes("m_dagMenuProc.kAddSelectedVertices"))
				    -echoCommand true						
				    -c $addSelectedVerticesCmd
				    -rp "E";
    				
			    $radialPositionUsed[size($radialPositionUsed)] = "E";

                string $removeSelectedVerticesCmd = "artSkinSelectVerticesForInfluence " + $item + " 0 1";
			    menuItem -l (uiRes("m_dagMenuProc.kDeselectAffectedVertices"))
				    -echoCommand true	
				    -c $removeSelectedVerticesCmd					
				    -rp "SE";					
				    			
			    $radialPositionUsed[size($radialPositionUsed)] = "SE";
						
		        string $selectCmd = "setSmoothSkinInfluence " + $item + ";";
		        $selectCmd += "artSkinRevealSelected artAttrSkinPaintCtx";
		        menuItem -l (uiRes("m_dagMenuProc.kSelectInfluence"))
				-echoCommand true
				-c $selectCmd
				-rp "N";
				
				$radialPositionUsed[size($radialPositionUsed)] = "N";							    
			}
			else
			{
			    
			    string $setPaintModeCmd = "artAttrSkinSetPaintMode 1";
			    menuItem -l (uiRes("m_dagMenuProc.kSetPaintMode"))
				    -echoCommand true						
				    -c $setPaintModeCmd
				    -rp "NW";
    				
			    $radialPositionUsed[size($radialPositionUsed)] = "NW";
			    
			    string $setSelectModeCmd = "artAttrSkinSetPaintMode 0";
			    menuItem -l (uiRes("m_dagMenuProc.kSetSelectMode"))
				    -echoCommand true						
				    -c $setSelectModeCmd
				    -rp "E";
    				
			    $radialPositionUsed[size($radialPositionUsed)] = "E";

                string $setPaintSelectModeCmd = "artAttrSkinSetPaintMode 2";
			    menuItem -l (uiRes("m_dagMenuProc.kSetPaintSelectMode"))
				    -echoCommand true	
				    -c $setPaintSelectModeCmd					
				    -rp "SE";					
				    			
			    $radialPositionUsed[size($radialPositionUsed)] = "SE";
			}			
		}
	}
}

global proc createSelectMenuItems(string $parent, string $item)
// Create a menu that shows the dag parenting for this object
{
	string $maskList[] = `objectSelectMasks($item)`;

	string $radialPosition[];
	string $uiName;

	int $i;
	int $isNurbObject     = false;
	int $isBezierObject   = false;
	int $isPolyObject     = false;
	int $isLatticeObject  = false;
	int $isJointObject    = false;
	int $isHikEffector	  = false;
	int $isIkHandleObject = false;
	int $isIkFkHandleObject = false;	
	int $isParticleObject = false;
	int $isSpringObject   = false;
	int $isSubdivObject   = false;
	int $isLocatorObject  = false;
	int $hasComponents	  = false;

	//	Comparing an element in an empty array will increase the array
	//	to accomodate that element.
	//
	//	To avoid this, first test the size of the array before comparing
	//	elements that may not exist.
	//
	if (1 <= size($maskList)) {
		$isLatticeObject = ($maskList[0] == "latticePoint");
		$isJointObject = ($maskList[0] == "joint");
		$isHikEffector = ($maskList[0] == "hikEffector");
		$isIkHandleObject = ($maskList[0] == "ikHandle");
		$isParticleObject = ($maskList[0] == "particle");
		$isSpringObject = ($maskList[0] == "springComponent");
		$isSubdivObject = ($maskList[0] == "subdivMeshPoint");
		$isLocatorObject = ($maskList[0] == "locator");
	}
	if (2 <= size($maskList)) {
		$isBezierObject = ($maskList[1] == "bezierAnchor");
		$isNurbObject = ($maskList[1] == "controlVertex");
		$isPolyObject = ($maskList[1] == "vertex");
	}

	// $maxRadialPos keeps track of how many octants of the
	// RMB marking menu will be populated
	//
	int $maskSize = size($maskList);
	int $maxRadialPos = size($maskList);

	if (($maskSize > 0) && ($maskList[$maskSize-1] == "ikfkHandle")) {
		$isIkFkHandleObject = true;
		$maxRadialPos--; // ikfkHandle does not populate like other masks
	}

	$hasComponents = $isLatticeObject || 
					 $isParticleObject ||
					 $isSubdivObject ||
					 $isSpringObject ||
					 $isNurbObject ||
					 $isPolyObject ||
					 $isBezierObject;

	// NOTE: 
	//			If the object has selectable components, then the
	//		radial position "NE" will be used for the menuItem:  
	//		"Revert back to object mode."
	//
	setParent -menu $parent;
	$radialPosition[0] = "N";
	$radialPosition[1] = "W";
	$radialPosition[2] = "S";
	$radialPosition[3] = "E";
	$radialPosition[4] = "SW";
	$radialPosition[5] = "SE";
	$radialPosition[6] = "NW";
	$radialPosition[7] = "NE";
	
	string $radialPositionUsed[];
    
    string $disableikHandle = (uiRes("m_dagMenuProc.kDisableIkHandle")); 
    string $enableIkHandle  = (uiRes("m_dagMenuProc.kEnableIkHandle"));
	string $setPreferred	= (uiRes("m_dagMenuProc.kSetPreferredAngle"));
	string $assumePreferred = (uiRes("m_dagMenuProc.kAssumePreferredAngle")); 
	
	if( $isBezierObject ) {
		for ($i = 0; $i < size($maskList); $i++) {			  
			  $uiName = `dagMenuProc_selectionMask_melToUI $maskList[$i]`;			  
			if ($maskList[$i] != "ikfkHandle") {
				string $mask = $maskList[$i];
				if( $mask == "bezierAnchor" )
				{
					$mask = "controlVertex";
				}
				if( $mask == "editPoint" )
				{
					continue;
				}
				menuItem -label $uiName
					-ecr false
					-c ( "doMenuNURBComponentSelection(\"" +
						 $item + "\", \"" +  $mask + "\")")
					-rp $radialPosition[$i];
			}
		}
	}
	else if ($isNurbObject) {        
        
        populateMMForPaintSkinWeights($item,$radialPositionUsed);
		string $listRelatives[] = `listRelatives -pa -s $item`;
        
		if ( (size($listRelatives) > 0) && ( size ( `findRelatedSkinCluster ( $item )` ) > 0 ) && ( `nodeType $listRelatives[0]` == "nurbsSurface" ) )
		{		    		    

            if(!isRadialPositionUsed($radialPositionUsed,"NW"))
            {
			    menuItem -l (uiRes("m_dagMenuProc.kPaintSkinWeightsTool"))
				    -echoCommand true
				    -c ( "ArtPaintSkinWeightsToolOptions; changeSelectMode -object; select -add " + $item) 
				    -rp "NW";
				$radialPositionUsed[size($radialPositionUsed)] = "NW";
			}
		}
		
		for ($i = 0; $i < size($maskList); $i++) {			  
			$uiName = `dagMenuProc_selectionMask_melToUI $maskList[$i]`;	
			if ($maskList[$i] != "ikfkHandle") {
			    if(!isRadialPositionUsed($radialPositionUsed,$radialPosition[$i]))
			    {
				    menuItem -label $uiName
					    -ecr false
					    -c ( "doMenuNURBComponentSelection(\"" +
						     $item + "\", \"" +  $maskList[$i] + "\")")
					    -rp $radialPosition[$i];
			    }
			}
		}				


	} else if ($isPolyObject) {			    	    

        populateMMForPaintSkinWeights($item,$radialPositionUsed);	

		string $listRelatives[] = `listRelatives -pa -s $item`;
        
		if ( (size($listRelatives) > 0) && ( size ( `findRelatedSkinCluster ( $item )` ) > 0 ) && ( `nodeType $listRelatives[0]` == "mesh" ) )
		{		    		    

            if(!isRadialPositionUsed($radialPositionUsed,"NW"))
		    {
			    menuItem -l (uiRes("m_dagMenuProc.kPolyPaintSkinWeightsTool"))
				    -echoCommand true
				    -c ( "ArtPaintSkinWeightsToolOptions; changeSelectMode -object; select -add " + $item) 
				    -rp "NW";
				$radialPositionUsed[size($radialPositionUsed)] = "NW";
			}
		}
		
		for ($i = 0; $i < size($maskList); $i++) {				
			$uiName = `dagMenuProc_selectionMask_melToUI $maskList[$i]`;
			if ($maskList[$i] != "ikfkHandle") {
			    if(!isRadialPositionUsed($radialPositionUsed,$radialPosition[$i]))
			    {
				    menuItem -label $uiName
					    -ecr false
					    -c ( "doMenuComponentSelection(\"" +
						     $item + "\", \"" +  $maskList[$i] + "\")")
					    -rp $radialPosition[$i];
				}
			}
		}				

	} else if ($isLatticeObject) {
		for ($i = 0; $i < size($maskList); $i++) {
			if ($maskList[$i] != "ikfkHandle") {
				$uiName = `dagMenuProc_selectionMask_melToUI $maskList[$i]`;
				menuItem -label $uiName
					-ecr false
					-c ( "doMenuLatticeComponentSelection(\"" +
						 $item + "\", \"" +  $maskList[$i] + "\")")
					-rp $radialPosition[$i];
			}
		}
	} else if ($isJointObject) {
		string $setCmd = `performSetPrefAngle 2`;
		string $assumeCmd = `performAssumePrefAngle 2`;		
		$setCmd += (" "+$item);
		$assumeCmd += (" "+$item);
		string $jts[] = `ls -sl -type joint`;
		for ($jointItem in $jts) {
			if ($jointItem != $item) {
				$setCmd += (" "+$jointItem);
				$assumeCmd += (" "+$jointItem);
			}
		}				
		
	    string  $currContext = `currentCtx`;
	    string  $currTool    = `contextInfo -c $currContext`;
	    if ( $currTool != "artAttrSkin" )
	    {
	        string $setPreferredQuad = "W";
		    string $assumePreferredQuad = "E";
    				    
    		
		    string $hikHandle[] = `listConnections -type hikHandle $item`;
		    int $isFBIKjoint = (size($hikHandle) > 0);
		    if ($isFBIKjoint) {
			    createFBIKmenuItems($parent, $item,"W","NE","E","SE");
			    
			    $setPreferredQuad = "N";			        
			    $assumePreferredQuad  = "S";
		    }
		
		    menuItem -label $setPreferred 
                -echoCommand true
                -c ($setCmd)
                -rp $setPreferredQuad
                setPrefAngleItem;
		
	        menuItem -label $assumePreferred 
		        -echoCommand true
		        -c ($assumeCmd)
		        -rp $assumePreferredQuad
		        assumePrefAngleItem;
	    }
	    else
	    {
	        populateMMForPaintSkinWeights($item,$radialPositionUsed);		    
	    }
	    

	} else if ($isHikEffector){
		if (nodeType($item) == "hikFloorContactMarker") {
			string $parentItems[] = `listRelatives -pa -p $item`;
			if (size($parentItems) &&
				nodeType($parentItems[0]) == "hikEffector") {
				$item = $parentItems[0];
			} else {
				$isHikEffector = false;
			}
		}

		if ($isHikEffector) {
		    string $pivotOffsetPlug = $item + ".pivotOffset";
		    float $pivotOffset[] = `getAttr $pivotOffsetPlug`;
		    int $enablePin = (equivalentTol($pivotOffset[0],0.0,0.001) &&
		                      equivalentTol($pivotOffset[1],0.0,0.001) &&
		                      equivalentTol($pivotOffset[2],0.0,0.001));
		    
			// set pinning for hikEffectors
			menuItem -label (uiRes("m_dagMenuProc.kPinBoth")) 
				-echoCommand true
				-c ("doPinHikEffectors 1 {\"3\",\"" + $item + "\"};")
				-enable $enablePin
				-rp "N"
				pinAllItem;
			
			menuItem -label (uiRes("m_dagMenuProc.kPinTranslate")) 
				-echoCommand true
				-c ("doPinHikEffectors 1 {\"1\",\"" + $item + "\"};")
				-enable $enablePin
				-rp "NW"
				pinTransItem;
			
			menuItem -label (uiRes("m_dagMenuProc.kPinRotate")) 
				-echoCommand true
				-c ("doPinHikEffectors 1 {\"2\",\"" + $item + "\"};")
				-enable $enablePin
				-rp "SW"
				pinRotItem;
			
			menuItem -label (uiRes("m_dagMenuProc.kUnpin")) 
				-echoCommand true
				-c ("doPinHikEffectors 1 {\"0\",\"" + $item + "\"};")
				-rp "S"
				unpinItem;
			
			createFBIKmenuItems($parent, $item,"W","NE","E","SE");
		}
	} else if ($isLocatorObject) {
		populateMMForPaintSkinWeights($item,$radialPositionUsed);	

	} else if ($isIkHandleObject) {
		string $selectikHandlesJointsAnnot = (uiRes("m_dagMenuProc.kSelectikHandlesAnnot"));
		string $selectikHandlesAnnot = (uiRes("m_dagMenuProc.kEnableIKHandlesAnnot"));
		menuItem -label $setPreferred
			-annotation $selectikHandlesJointsAnnot 
			-echoCommand true
			-c (`performSetPrefAngle 2` + " " + $item)
			-rp "W"
			setPrefAngleItem;

		menuItem -label $assumePreferred 
			-annotation $selectikHandlesJointsAnnot 
			-echoCommand true
			-c (`performAssumePrefAngle 2` + " " + $item)
			-rp "E"
			assumePrefAngleItem;

		menuItem -label $enableIkHandle 
			-annotation $selectikHandlesAnnot 
			-echoCommand true
			-c ("ikHandle -e -eh " + $item)
			-rp "N"
			enableIKHandlesItem;

		menuItem -label $disableikHandle 
			-annotation $selectikHandlesAnnot 
			-echoCommand true
			-c ("ikHandle -e -dh " + $item)
			-rp "S"
			disableIKHandlesItem;

		menuItem -label (uiRes("m_dagMenuProc.kEnableSnap")) 
			-annotation $selectikHandlesAnnot
			-echoCommand true
			-c ("ikHandle -e -see " + $item + ";" +
				"ikHandle -e -shf on " + $item)
			-rp "SE"
			enableIKHandlesSnapItem;

		menuItem -label (uiRes("m_dagMenuProc.kDisableSnap")) 
			-annotation $selectikHandlesAnnot 
			-echoCommand true
			-c ("ikHandle -e -shf off " + $item)
			-rp "SW"
			disableIKHandlesSnapItem;

		$maxRadialPos = 6;
	} else if ($isParticleObject) {
		for ($i = 0; $i < size($maskList); $i++) {			   
			   $uiName = `dagMenuProc_selectionMask_melToUI $maskList[$i]`;			   			
			menuItem -label $uiName
				-ecr false
				-c ( "doMenuParticleComponentSelection(\"" +
					$item + "\", \"" +  $maskList[$i] + "\")")
				-rp $radialPosition[$i];
		}
	} else if ($isSpringObject) {
		for ($i = 0; $i < size($maskList); $i++) {			   
			   $uiName = `dagMenuProc_selectionMask_melToUI $maskList[$i]`;			
			menuItem -label $uiName
				-ecr false
				-c ( "doMenuSpringComponentSelection(\"" +
					$item + "\", \"" +  $maskList[$i] + "\")")
				-rp $radialPosition[$i];
		}
	} else if ($isSubdivObject) {				
	    subdDagMenuProc( 0, $item, $maskList );	    
	} else {
		for ($i = 0; $i < size($maskList); $i++) {
			if ($maskList[$i] == "ikfkHandle") {
				continue;
			}
			
			$uiName = `dagMenuProc_selectionMask_melToUI $maskList[$i]`;
			menuItem -label $uiName
				-ecr false
				-c ( "doMenuComponentSelection(\"" +
					$item + "\", \"" +  $maskList[$i] + "\")")
				-rp $radialPosition[$i];
		}
	} 

	// If components are present, provide the ability to 
	// get back to object mode...
	//
	if ($hasComponents && ( `artAttrCtx` != "artAttrSkinContext" )) {
		menuItem -label (uiRes("m_dagMenuProc.kObjectMode")) 
				-ecr false
				-c ("maintainActiveChangeSelectMode " + $item + ";")
				-rp "NE";
	}

	// Since any object can be an ikfk handle, we only populate the ikfk items
	// in slots that are not already in use.
	//
	if ($isIkFkHandleObject) {
		string $handle = getControlledHandle($item);

		if ($maxRadialPos < 8) {
			menuItem -label (uiRes("m_dagMenuProc.kSetIKFKKey")) 
				-echoCommand true
				-annotation (uiRes("m_dagMenuProc.kSetKeysAnnot")) 
				-rp $radialPosition[7]
				-command ("select -r "+$item+"; SetIKFKKeyframe");
		}

		if ($maxRadialPos < 7) {
			menuItem -label (uiRes("m_dagMenuProc.kMoveIKToFK")) 
				-echoCommand true
				-annotation (uiRes("m_dagMenuProc.kSelectAnIKHandleOrIKFKAnnot")) 
				-rp $radialPosition[6]
				-command ("select -r "+$item+"; MoveIKtoFK");
		}

		if ($maxRadialPos < 5) {
			menuItem -label $disableikHandle 
				-annotation (uiRes("m_dagMenuProc.kDisableIKHandleAnnot")) 
				-echoCommand true
				-c ("ikHandle -e -dh " + $handle)
				-rp $radialPosition[5];

			menuItem -label $enableIkHandle 
				-annotation (uiRes("m_dagMenuProc.kEnableIKHandleAnnot")) 
				-echoCommand true
				-c ("ikHandle -e -eh " + $handle)
				-rp $radialPosition[4];
		}
	}
	
	
//	for ($i = 0; $i < size($maskList); $i++) {
//       $itemName = "SELM" + string($i);
//			setParent -menu $parent;
//			menuItem
//				-c ("doMenuComponentSelection(\"" + 
//					$item + "\", \"" +  $maskList[$i] + "\")")
//				-label $maskList[$i]
//				-rp $radialPosition[$i]
//				$itemName;
//	}
	setParent -menu $parent;
}

global proc doMenuNURBComponentSelection(string $item, string $mask)
//
// Change the selection/display state to allow selection of NURB components
//
{
	string $selectCmd;
	string $warn = (uiRes("m_dagMenuProc.kEditUVModeWarn"));
	
	if (`selectMode -q -object`) {
		hilite $item;
		selectType -ocm -alc false;
		$selectCmd = "selectType -ocm -" + $mask + " true;";

		// Test for implicit UVs - If we are in implicit UV mode
		// UVs are not selectable. So issue a warning.
		//
		if( $mask == "surfaceUV" )
		{
			int $isExplicit[] = `nurbsUVSet -q -ue $item`;
			if( !$isExplicit[0] )
			{
				warning(`format -s $item $warn`);
			}
		}
	} else {
		selectType -alc false;
		$selectCmd = "selectType -" + $mask + " true;";
		if (`selectMode -q -preset`) {
			$selectCmd = $selectCmd +"selectPriority -allComponents 1;";
			$selectCmd = $selectCmd +"selectPriority -isoparm 2;";
			$selectCmd = $selectCmd +"selectPriority -" + $mask + " 3;";
			switch ($mask) {
				case "surfaceUV":
					$selectCmd = $selectCmd + 
						"toggle -state true -uv " + $item + ";";
					$selectCmd = $selectCmd + 
						"toggle -state false -hull " + $item + ";";
					$selectCmd = $selectCmd + 
						"toggle -state false -controlVertex " + $item + ";";
					$selectCmd = $selectCmd + 
						"toggle -state false -editPoint " + $item + ";"; 

					// Test for implicit UVs - If we are in implicit UV mode
					// UVs are not selectable. So issue a warning.
					//
					int $isExplicit[] = `nurbsUVSet -q -ue $item`;
					if( !$isExplicit[0] )
					{
						warning(`format -s $item $warn`);
					}
					break; 
				case "editPoint":
					$selectCmd = $selectCmd + 
						"toggle -state true -" + $mask + " " + $item +";"; 
					$selectCmd = $selectCmd + 
						"toggle -state false -hull " + $item + ";";
					$selectCmd = $selectCmd + 
						"toggle -state false -controlVertex " + $item + ";";
					$selectCmd = $selectCmd +
						"toggle -state false -uv " + $item + ";";
					break;
				case "controlVertex":
					$selectCmd = $selectCmd + 
						"toggle -state true -" + $mask + " " + $item +";"; 
					$selectCmd = $selectCmd + 
						"toggle -state false -hull " + $item + ";";
					$selectCmd = $selectCmd + 
						"toggle -state false -editPoint " + $item + ";";
					$selectCmd = $selectCmd +
						"toggle -state false -uv " + $item + ";";
					break;
				case "hull":
					$selectCmd = $selectCmd + 
						"toggle -state true -" + $mask + " " + $item + ";"; 
					$selectCmd = $selectCmd + 
						"toggle -state false -controlVertex " + $item + ";";
					$selectCmd = $selectCmd + 
						"toggle -state false -editPoint " + $item + ";";
					$selectCmd = $selectCmd +
						"toggle -state false -uv " + $item + ";";
					break;
				default:
					$selectCmd = $selectCmd + 
						"toggle -state false -hull " + $item + ";";
					$selectCmd = $selectCmd + 
						"toggle -state false -controlVertex " + $item + ";";
					$selectCmd = $selectCmd + 
						"toggle -state false -editPoint " + $item + ";";
					$selectCmd = $selectCmd +
						"toggle -state false -uv " + $item + ";";
					break;
			}
		} else {
			$selectCmd = $selectCmd + "hilite " + $item + ";";

			// Test for implicit UVs - If we are in implicit UV mode
			// UVs are not selectable. So issue a warning.
			//
			int $isExplicit[] = `nurbsUVSet -q -ue $item`;
			if( !$isExplicit[0] )
			{
			    warning(`format -s $item $warn`);
			}
		}
	}

	eval $selectCmd;
}

global proc doMenuLatticeComponentSelection(string $item, string $mask)
//
// Changes the selection/display state on this object to allow
// selection of the Lattice control points
{
	string $selectCmd;

	if (`selectMode -q -object`) {
		hilite $item;
		selectType -ocm -alc false;
		$selectCmd = "selectType -ocm -" + $mask + " true;";
	} else {
		selectType -ocm -alc false;
		$selectCmd = "selectType -" + $mask + " true;";
		if (!`selectMode -q -preset`) {
			$selectCmd = $selectCmd + "hilite " + $item + ";";
		} else {
			$selectCmd = $selectCmd + "toggle -" + $mask + ";"; 
		}
	}
	eval $selectCmd;
}


global proc doMenuParticleComponentSelection(string $item, string $mask)
//
// Change the selection/display state to allow selection of particle
// components
//
{
	string $selectCmd;

	if (`selectMode -q -object`) {
		hilite $item;
		selectType -ocm -alc false;
		$selectCmd = "selectType -ocm -" + $mask + " true;";
	} else {
		selectType -ocm -alc false;
		$selectCmd = "selectType -" + $mask + " true;";
		if (`selectMode -q -preset`) {
			$selectCmd = $selectCmd +"selectPriority -allComponents 1;";
			$selectCmd = $selectCmd +"selectPriority -particle 2;";
			$selectCmd = $selectCmd +"selectPriority -" + $mask + " 3;";
			switch ($mask) {
				case "particle":
					$selectCmd = $selectCmd + 
						"toggle -state true -" + $mask + " " + $item +";"; 
					break;
				default:
					$selectCmd = $selectCmd + 
						"toggle -state false -particle " + $item + ";";
					break;
			}
		} else {
			$selectCmd = $selectCmd + "hilite " + $item + ";";
		}
	}

	eval $selectCmd;
}


global proc doMenuSpringComponentSelection(string $item, string $mask)
//
// Change the selection/display state to allow selection of spring
// components
//
{
	string $selectCmd;

	if (`selectMode -q -object`) {
		hilite $item;
		selectType -ocm -alc false;
		$selectCmd = "selectType -ocm -" + $mask + " true;";
	} else {
		selectType -ocm -alc false;
		$selectCmd = "selectType -" + $mask + " true;";
		if (`selectMode -q -preset`) {
			$selectCmd = $selectCmd +"selectPriority -allComponents 1;";
			$selectCmd = $selectCmd +"selectPriority -springComponent 2;";
			$selectCmd = $selectCmd +"selectPriority -" + $mask + " 3;";
			switch ($mask) {
				case "springComponent":
					$selectCmd = $selectCmd + 
						"toggle -state true -" + $mask + " " + $item +";"; 
					break;
				default:
					$selectCmd = $selectCmd + 
						"toggle -state false -springComponent " + $item + ";";
					break;
			}
		} else {
			$selectCmd = $selectCmd + "hilite " + $item + ";";
		}
	}

	eval $selectCmd;
}


global proc doMenuComponentSelection(string $item, string $mask)
//
// Changes the selection/display state on this object to allow
// selection of the specified selection mask type.
{
	string $selectCmd;

	if (`selectMode -q -object`) {
		hilite $item;
		selectType -ocm -alc false;
		$selectCmd = "selectType -ocm -" + $mask + " true;";
	} else {
		selectType -ocm -alc false;
		$selectCmd = "selectType -" + $mask + " true;";
		if (!`selectMode -q -preset`) {
			$selectCmd = $selectCmd + "hilite " + $item + ";";
		}
	}
	eval $selectCmd;
}

global proc undoMenuComponentSelection(string $item, string $mask)
{
	string $selectCmd;

	if (`selectMode -q -object`) {
		$selectCmd = "selectType -ocm -" + $mask + " false;";
	} else {
		$selectCmd = "selectType -" + $mask + " false;";
	}

	eval $selectCmd;
}

global proc toggleBoundingBoxDisplay ( string $parent )
//
// For each shape under the selected parent object, toggle the
// state of bounding box display mode.
//
{
	string $shapes[] = `listRelatives -shapes $parent`;

	string $shape;

	for ( $shape in $shapes ) {
		int $overrideOn = `getAttr ( $shape + ".overrideEnabled")`;
		int $lodMode =    `getAttr ( $shape + ".overrideLevelOfDetail")`;
		int $enabled =     $overrideOn && $lodMode == 1;

		if ( $enabled ) {
			// Don't reset the overrideEnabled attribute. It
			// is used for more than just bounding box display
			// and turning if off will mess things up of you
			// have temporarily enabled bounding box display 
			// of an object in a layer.
			setAttr ( $shape + ".overrideLevelOfDetail" ) 0;
		} else {
			setAttr ( $shape + ".overrideEnabled") 1;
			setAttr ( $shape + ".overrideLevelOfDetail") 1;
		}

	}
}

global proc createActionsMenuItems(string $parent, string $item)
//
// Creates a menu with common operations to perform on an object
//
{	
	popupMenu -e -dai $parent;
	setParent -menu $parent;

	menuItem -label (uiRes("m_dagMenuProc.kTemplate"))  -c ("toggle -template -state on " + $item);
	menuItem -label (uiRes("m_dagMenuProc.kUntemplate"))  -c ("toggle -template -state off " + $item);
	menuItem -label (uiRes("m_dagMenuProc.kUnparent"))  -c ("parent -w " + $item);
	menuItem -label (uiRes("m_dagMenuProc.kBoundingBox"))  -c ("toggleBoundingBoxDisplay " + $item);
}


global proc showSG(string $item)
//
//	Display the Attribute Editor and show the tab for the
//	shading group that is on the object $item.
//
//  If would have been nicer to be able to use the
//	showShadingGroupAttributeEditor command, but it only 
//  acts on the	selected object.
//
{
	//check selection list for faces (polys, subds, nurbs)
	string $shader = "";
	string $selection[] = `filterExpand -sm 34 -sm 38 -sm 72`;

	// If there are components selected, try to find a component shader
	if( size( $selection ) > 0)
	{
		string $nameBuffer[];

		int $numComps = size( $selection );
		int $comp;
		for( $comp = 0; $comp < $numComps; $comp++)
		{
			tokenize $selection[ $comp] "." $nameBuffer;

			//if the selected component is on the object under the pointer
			//get it's shader
			if ($nameBuffer[0] == $item) {
				$shader = `getComponentShader $selection[$comp]`;

				//check if the shader is already selected - only toggle
				//selection if it is not selected
				string $shaderSelected[] = `ls -selection $shader`;
				if ( size( $shaderSelected ) == 0){
					select -tgl $shader;
				
				}
				break;
			}
		}
	}

	// If we didn't find a component level shader, try for an object level one
	if( size( $shader ) == 0 ) {
		string $allNodes[] = (`listHistory -f true $item` );
		string $node = "";
		for ($node in $allNodes) {
			if(`nodeType $node` == "shadingEngine") {

				$shader = $node;
				break;
			}
		}
	}

	// If we found a shader, show it
	if( size( $shader ) > 0) 
	{
		showEditor $shader;
	}
}
	
global proc showBakeSets(string $item, string $type)
//
//	Display the Attribute Editor and show the tab for the
//	first bake set of the specified $type that the object $item is in.
//  If there is no this $type of bake set in the scene, creates the
//  initial bake set of this type and show it in the attribute editor.
//
//  If would have been nicer to be able to use the
//	showBakeSetAttributeEditor command, but it only 
//  acts on the	selected object.
//
{
	string $possibleBakeSets[] = (`listHistory -f true $item` );
	string $node = "";
    int $bakeSetExists = false;
	for ($node in $possibleBakeSets) {
		if(`nodeType $node` == $type)
        {
			showEditor $node;
            $bakeSetExists = true;
			break;
		}
	}

    // If no bake set exists for the $item, then create the
    // initial bake set of that $type and assign it to the $item.
    //
    if (!$bakeSetExists)
    {
        string $initialBakeSet = "";
		if($type == "vertexBakeSet") 
        {
            $initialBakeSet = "initialVertexBakeSet";
        }
        else if($type == "textureBakeSet") 
        {
            $initialBakeSet = "initialTextureBakeSet";
		}
        else
        {
            string $errorMsg = (uiRes("m_dagMenuProc.kBakeSetError"));
            error   -showLineNumber true
                (`format -s $type $errorMsg`);
            return;
        }

        // Create it if it does not exist yet.
        //
        if  ( size(`ls $initialBakeSet`) < 1)
        {
            createBakeSet($initialBakeSet, $type);
        } 
    
        // Assign the initial bake set to the item.
        //
        assignBakeSet($initialBakeSet, $item);

        // Show the initial bake set.
        //
        showBakeSetAE($initialBakeSet);
    }
}

// Description:  This procedure is called to refresh the baking 
//  attribute menu items.
//
global proc refreshBakingAttributeMenu (string $parent, string $item)
{
    setParent -menu $parent;

    int $suitable = bakeSetTypeSuitableForItem("textureBakeSet", $item);
    menuItem -edit -enable $suitable textureBakingAttributeItem;
    $suitable = bakeSetTypeSuitableForItem("vertexBakeSet", $item);
    menuItem -edit -enable $suitable vertexBakingAttributeItem;
}

// Description:  This procedure is called to create the 
//  baking attribute menu.
//
proc createBakingAttributeMenu(string $parent, string $item)
{
    setParent -menu $parent;

	menuItem -label (uiRes("m_dagMenuProc.kEditAttributes"))  
        -subMenu true
        -tearOff true
        -postMenuCommand ("refreshBakingAttributeMenu \""
                            +$parent+"|editAttributeItem\" \""
                            +$item+"\"")
        editAttributeItem; 


        menuItem -label (uiRes("m_dagMenuProc.kTexture"))  
            -c ("showBakeSets \""+$item+"\" \"textureBakeSet\"") 
            textureBakingAttributeItem;
        menuItem -label (uiRes("m_dagMenuProc.kVertexMenuLabel"))  
            -c ("showBakeSets \""+$item+"\" \"vertexBakeSet\"") 
            vertexBakingAttributeItem;

    setParent -menu ..;
}

// Description:  This procedure is called to create the baking
//  menu items.
//
global proc createBakingMenuItems(string $parent, string $item)
//
//	Create the Baking menus for the RMB popup menu.
//
{
	popupMenu -e -deleteAllItems $parent;
	setParent -menu $parent;

    createBakingAttributeMenu($parent, $item);
	menuItem -d true;

	if (!`about -evalVersion`) {
		buildBakingMenus($item);
	}
}

// Description:  This procedure is called to create the switch proxy
//  menu items.
//
global proc createSwitchProxyMenuItems(string $parent, string $item, string $refNode)
//
//	Create the switch proxy submenu for the RMB popup menu.
//
{
	popupMenu -e -deleteAllItems $parent;
	setParent -menu $parent;

	string $proxyNodes[] = `getRelatedProxies $refNode`;
	int $i;
	string $proxyLabel;
	string $proxyTag;
	for( $i=0; $i<size($proxyNodes); $i+=1) {
		$proxyTag = `getAttr ($proxyNodes[$i] + ".proxyTag")`;
		
		menuItem -label $proxyTag -c ("proxySwitch " + $proxyNodes[$i]);
	}
}

global proc createHistoryMenuItems(string $parent, string $item)
//
// Creates a menu on the toolbar that shows a list of
// all operations that took place to create/modify
// the currently selected object.  Note that the list
// is not being filtered yet to get rid of things that
// users won't really care about, nor are the operations
// being listed as operations - their DG node names are
// simply being stuck into the menu.  This should
// change.
//
// Also note that the chain of operations limit is being
// hardcoded to 20 here, for the sake of speed.
//
{
	//
	// Delete all menu entries currently in the popup
	//
	popupMenu -e -dai $parent;
	setParent -menu $parent;

	historyPopupFill( $item, false, 1 );
}

global proc createFutureMenuItems(string $parent, string $item)
//
// Creates a menu on the toolbar that shows a list of
// all operations that took place to create/modify
// the currently selected object.  Note that the list
// is not being filtered yet to get rid of things that
// users won't really care about, nor are the operations
// being listed as operations - their DG node names are
// simply being stuck into the menu.  This should
// change.
//
// Also note that the chain of operations limit is being
// hardcoded to 20 here, for the sake of speed.
//
{
	//
	// Delete all menu entries currently in the popup
	//
	popupMenu -e -dai $parent;
	setParent -menu $parent;

	historyPopupFill( $item, true, 1 );
}

global proc string objectHandlesUvSets(string $item)
{
	string $maskList[];
	string $shape = $item;
	int $i;

	// Look at the shape child of this object
	//
	string $object[] = `listRelatives -path -s $item`;
	int $gotVisible = 0;

	for ($i = 0; $i < size($object); ++$i) {
		if( (0 == getAttr($object[$i] + ".io")) &&
			getAttr($object[$i] + ".v") ) {
			$shape = $object[$i];
			$gotVisible = 1;
			break;
		}
	}

	if( !$gotVisible ) {
		for ($i = 0; $i < size($object); ++$i)
		{
			if (getAttr($object[$i] + ".io") == 0)
			{
				$shape = $object[$i];
				break;
			}
		}
	}
	string $nt = `nodeType $shape`;

	if ($nt == "mesh")	
		return $shape;
	return "";
}

global proc createUVsetMenuItems(string $parent, string $item,
								 string $shape)
{
	popupMenu -e -dai $parent;
	setParent -menu $parent;

	string $cmd = "polyUVSet -currentUVSet -uvSet ";
	string $curSetPI[] = `polyUVSet -q -currentPerInstanceUVSet $shape`;
	string $curSet[] = `polyUVSet -perInstance 1 -q -currentUVSet $shape`;	
	string $names[] = `polyUVSet -perInstance true -q -allUVSets $shape`;
	int $numNames = size($names);
	for ($ii = 0; $ii < $numNames; $ii++) {
		string $perInst[] = `polyUVSet -uvSet $names[$ii] -q -pi $shape`;
		if (size($perInst) > 0 && size($perInst[0]) > 0) {
			$names[$ii] = $perInst[0];
		}
	}

	string $allProjects[] = `polyUVSet -pr -q $shape`;
	string $setClearCmd = "";
	if (size($allProjects))
	{
		$setClearCmd = "select -d ";		
		for ($p=0; $p<size($allProjects); $p++)
			$setClearCmd += (" " + $allProjects[$p]);
		$setClearCmd += ";";
	}

	// Add in a menu to do uv-linking
	if ($numNames > 0)
	{	
		string $ann = `getRunTimeCommandAnnotation "UVCentricUVLinkingEditor"`;
		string $cmd = "UVCentricUVLinkingEditor; " + "select -r " + $item;
		menuItem -label (uiRes("m_dagMenuProc.kUVLinking")) 
			-c $cmd
			-annotation $ann;

		menuItem -label (uiRes("m_dagMenuProc.kUVSetEditor")) 
			-c "UVSetEditor"
			-ann (getRunTimeCommandAnnotation("UVSetEditor"))
			;
		menuItem -divider true;
	}

	for ($i=0; $i<$numNames; $i++)
	{
		string $uvEditname = ("\"" + $names[$i] + "\"");
		string $uvname = $names[$i];
		string $setCurCmd = $cmd + $uvEditname + " " + $shape + ";";

		// Find any projections associated with the uvset
		string $projs[];
		$projs = `polyUVSet -pr -uvs $uvname -q $shape`;
		string $projCmd;

		// Add a divider between items
		if ($i > 0)
			menuItem -divider true;

		if ($uvname == $curSet[0] || $uvname == $curSetPI[0])
		{
			menuItem -label ($uvname) -c $setClearCmd -checkBox true;
			for ($j=0; $j<size($projs); $j++)
			{
				$projCmd = ($setClearCmd + "select -add "+ $projs[$j] + ";setToolTo ShowManips;"); 
				menuItem -label $projs[$j] -c $projCmd;
				if ($j >= 5)
					break;
			}
		}
		else
		{
			menuItem -label ($uvname) -c ($setClearCmd + $setCurCmd) -checkBox false;
			for ($j=0; $j<size($projs); $j++)
			{
				$projCmd = ($setCurCmd + $setClearCmd + "select -add "+ $projs[$j] + ";setToolTo ShowManips;"); 
				menuItem -label $projs[$j] -c $projCmd;
				if ($j >= 5)
					break;
			}
		}
	}
}

//
global proc string objectHandlesColorSets(string $item)
{
	string $maskList[];
	string $shape = $item;
	int $i;

	// Look at the shape child of this object
	//
	string $object[] = `listRelatives -path -s $item`;
	int $gotVisible = 0;

	for ($i = 0; $i < size($object); ++$i) {
		if( (0 == getAttr($object[$i] + ".io")) &&
			getAttr($object[$i] + ".v") ) {
			$shape = $object[$i];
			$gotVisible = 1;
			break;
		}
	}

	if( !$gotVisible ) {
		for ($i = 0; $i < size($object); ++$i)
		{
			if (getAttr($object[$i] + ".io") == 0)
			{
				$shape = $object[$i];
				break;
			}
		}
	}
	string $nt = `nodeType $shape`;

	if ($nt == "mesh")	
		return $shape;

	return "";
}

global proc createColorSetMenuItems(string $parent, string $item,
								 string $shape)
{
	popupMenu -e -dai $parent;
	setParent -menu $parent;

	string $cmd = "polyColorSet -currentColorSet -colorSet ";
	string $curSet[] = `polyColorSet -q -currentColorSet $shape`;
	string $curSetPI[] = `polyColorSet -perInstance true -q -currentPerInstanceSet $shape`;	
	string $names[] = `polyColorSet -perInstance true -q -acs $shape`;
	string $rep[] = `polyColorSet -q -acs -representation $shape`;

	int $numNames = size($names);
	for ($ii = 0; $ii < $numNames; $ii++) {
		string $perInst[] = `polyColorSet -colorSet $names[$ii] -q -pi $shape`;
		if (size($perInst) > 0 && size($perInst[0]) > 0) {
			$names[$ii] = $perInst[0];
		}
	}

	// Add in a menu to access color set editor
	menuItem -label (uiRes("m_dagMenuProc.kColorSetEditor")) 
		-ann (getRunTimeCommandAnnotation("ColorSetEditor"))
		-command "colorSetEditor"
		;
	if ($numNames > 0)
	{	
	menuItem -divider true;
	}

	string $tool = `currentCtx`;

	for ($i=0; $i < $numNames; $i++)
	{
		string $colorEditname = ("\"" + $names[$i] + "\"");
		string $colorname = $names[$i];
		string $setCurCmd = $cmd + $colorEditname + " " + $shape + ";";

		// 302288: ensuring a consistent UI w.r.t. color set selection
		//
		if ($tool == "artAttrColorPerVertexContext")
		{
			$setCurCmd = $setCurCmd + " artAttrColorPerVertexValues(\"artAttrColorPerVertexContext\");";
		}

		// Add a divider between items
		if ($i > 0)
			menuItem -divider true;

		if ($colorname == $curSet[0] || $colorname == $curSetPI[0])
		{
			$colorname += "(" + $rep[2*$i+1] + ")";
			menuItem -label ($colorname) -checkBox true;
		}
		else
		{
			$colorname += "(" + $rep[2*$i+1] + ")";
			menuItem -label ($colorname) -c ($setCurCmd) -checkBox false;
		}
	}
}

global proc createArtAttrMenuItems(
	string 		$parent, 
	string 		$item
)
//
//	Description:
// 		Creates a menu that shows all the paintable attributes.
// 
//	NOTE: paintAttr are sorted by the paintable node type.
// 
{	
	popupMenu -e -dai $parent;
	setParent -menu $parent;
	
	// add default items which are always displayed in the context menu
	menuItem -p $parent -label (uiRes("m_dagMenuProc.kPaintSelect"))  -command "ArtPaintSelectToolOptions" ;
	menuItem -p $parent -label (uiRes("m_dagMenuProc.kThreeDPaint"))  -command "Art3dPaintToolOptions" ;
	menuItem -p $parent -label (uiRes("m_dagMenuProc.kSculpt"))  -command "SculptGeometryToolOptions" ;

	// Get all paintable attributes
	string $paintAttr = `artBuildPaintMenu $item`;
	string $paint = (uiRes("m_dagMenuProc.kPaint"));
	
	if ($paintAttr != "")
	{
		// if the menu item has not been created, create it.
		if( $parent == "" )
			$parent = `menuItem -subMenu true -aob true -label $paint `;
			
	
		// create special purpose painting menu items for objects
		// such as cloth
		//
		string $excludeNodes[] = createPaintingMenuItems( $parent, $item );

		// Create the menu.
		artAttrCreateMenuItems( $parent, $paintAttr, $excludeNodes );
		
	}
}

//
//	Description:
// 		Creates RMB menu for the ViewCube
// 
global proc createViewCubeMenuItems(
	string 		$parent
)
{
	popupMenu -e -dai $parent;
	setParent -menu $parent;	
	
	// (Menu item) Set view to home view
	menuItem -p $parent -label (uiRes("m_dagMenuProc.kViewCubeHome"))
		-command "viewManip -goHome";

	menuItem -divider true;

	// (Menu item) Toggles the selection lock.
	// This item is enabled if the selection lock is currently on or if
	// there is currently geometry selected.
	int $lockOn = `viewManip -q -toggleSelectionLock`;
	int $enabled = $lockOn;

	if (!$enabled)
	{
		string	$sel[] = `ls -sl -dag -geometry`;
		$enabled = (size($sel) > 0);
	}

	menuItem -p $parent -enable $enabled  -checkBox $lockOn
		-label (uiRes("m_dagMenuProc.kViewCubeSelectionLock"))
		-command "viewManip -toggleSelectionLock";

	menuItem -divider true;
	
	// (Menu item) Sets current view as the (scene) Home view 
	menuItem -p $parent -label (uiRes("m_dagMenuProc.kViewCubeSetHome"))
		-command "viewManip -setHome";
	
	// (Menu item) Reset the Home view to its default
	menuItem -p $parent -label (uiRes("m_dagMenuProc.kViewCubeResetHome"))
		-enable `viewManip -q -setHome`
		-command "viewManip -resetHome";
	
	// (Menu item) Sets current view as the (scene) Front view 
	menuItem -p $parent -label (uiRes("m_dagMenuProc.kViewCubeSetFront"))
		-command "viewManip -setFront";
	
	// (Menu item) Reset the Front view to its default
	menuItem -p $parent -label (uiRes("m_dagMenuProc.kViewCubeResetFront"))
		-enable `viewManip -q -setFront`
		-command "viewManip -resetFront";
		
	menuItem -divider true;
	
	// (Menu item) Opens preferences window to the ViewCube properties tab
	menuItem -p $parent -label (uiRes("m_dagMenuProc.kViewCubeProperties")) 
		 -command "preferencesWnd \"viewCube\";";

	menuItem -divider true;

	// (Menu item) Show help on the ViewCube
	menuItem -p $parent -label (uiRes("m_dagMenuProc.kHelpViewCube"))
		-command "showHelp ViewCube";
}

global proc skinPaintUseColorFeedback()
{
	int $querySkinPaintColorFeedback = `menuItem -q -cb useColorFeedbackCB`;
	
	if ($querySkinPaintColorFeedback == 0) 
	{ 		
		checkBoxGrp -e -value1 0 artisanRampUseRamp;
		artAttrSkinPaintCtx -e -useColorRamp false artAttrSkinContext ; artisanUpdateRampColorEnable;
	}
	else
	{
		checkBoxGrp -e -value1 1 artisanRampUseRamp;
		artAttrSkinPaintCtx -e -useColorRamp true artAttrSkinContext ; artisanUpdateRampColorEnable;
	}
}

global proc skinPaintXrayJoints()
{
	string $activePanel = `getPanel -wf`;
	int $match = `gmatch $activePanel "modelPanel*"`;
	if($match == 1)
	{
		int $currentXrayValue = `modelEditor -q -jointXray $activePanel`;
		if($currentXrayValue == 0)
		{
			modelEditor -e -jointXray 1 $activePanel;
		}
		else
		{
			modelEditor -e -jointXray 0 $activePanel;
		}
	}
}

global proc getActiveModelPanel()
{
	string $activePanel = `getPanel -wf`;
	int $match = `gmatch $activePanel "modelPanel*"`;
	if($match == 1)
	{
		int $currentIsolateValue = `isolateSelect -q -state $activePanel`;
		if($currentIsolateValue == 0)
		{
			enableIsolateSelect $activePanel 1;
			isolateSelect -state 1 $activePanel;
		}
		else
		{
			enableIsolateSelect $activePanel 0;
			isolateSelect -state 0 $activePanel;
		}
	}
}

global proc addSelectedToIsolation()
{
	string $activePanel = `getPanel -wf`;
	int $match = `gmatch $activePanel "modelPanel*"`;
	if($match == 1)
	{
		addSelectedToEditor $activePanel;
		isolateSelect -addSelected $activePanel;
	}
}
	
	
// This has been called because a menu press happened on a DAG object
// So find the Object submenu and add the DAG specific items to it.
//
global proc dagMenuProc(string $parent, string $object)
{
	global string $artSelectObject ;
	string $mode = "";

	if (`optionVar -exists currentMenuBarTab`) {
		$mode = `optionVar -q currentMenuBarTab`;
	} else {
		optionVar -sv currentMenuBarTab $mode;
	}
	
	if (($object == "CubeCompass"))
	{
		createViewCubeMenuItems($parent);
		return;
	}

	if (`popupMenu -e -exists $parent`) {
		setParent -m $parent;
		
		string  $currContext = `currentCtx`;		
		if ( $currContext == "artAttrSkinContext" )
		{
			createSelectMenuItems($parent, $object);
			
			string $shortName = `substitute ".*|" $object ""`;
			menuItem -label ($shortName + "...") -c ("showEditor "+$object);
			menuItem -divider true;
			menuItem -divider true;

			menuItem -divider true;
			menuItem -divider true;
			
			menuItem -label (uiRes("m_dagMenuProc.kDagMenuGotoBindPose")) -c "gotoBindPose";
			
			menuItem -divider true;
			menuItem -divider true;

			menuItem -label (uiRes("m_dagMenuProc.kDagMenuSelect"))  -c ("select -r " + $object);
			menuItem -label (uiRes("m_dagMenuProc.kDagMenuAddToSelection")) -c ("select -add " + $object);
			menuItem -label (uiRes("m_dagMenuProc.kDagMenuSelectHierarchy"))  -c ("select -hierarchy " + $object);
			
			menuItem -divider true;
			menuItem -divider true;
			
			string $activePanel = `getPanel -wf`;
			int $currentXrayValue = `modelEditor -q -jointXray $activePanel`;
			$xrayJointCB = `menuItem -subMenu false -cb $currentXrayValue  -c "skinPaintXrayJoints;" -label (uiRes("m_dagMenuProc.kDagMenuXRayJoints")) xrayJointsCB`;  
			setParent -m $parent;
			
			int $currentIsolateValue = `isolateSelect -q -state $activePanel`;
			$isolateParent = `menuItem -subMenu true -label (uiRes("m_dagMenuProc.kDagMenuIsolate"))`;
								menuItem -subMenu false -cb $currentIsolateValue  -c "getActiveModelPanel;" -label (uiRes("m_dagMenuProc.kDagMenuIsolateSelected")) $isolateParent;
								menuItem -subMenu false -label (uiRes("m_dagMenuProc.kDagMenuAddObject")) -c "addSelectedToIsolation;" $isolateParent;										
			setParent -m $parent;										
			
			menuItem -divider true;
			menuItem -divider true;
			
			int $artAttrUseColorRamp = `checkBoxGrp -q -value1 artisanRampUseRamp`;
			$colorRampCB = `menuItem -subMenu false -cb $artAttrUseColorRamp  -c "skinPaintUseColorFeedback;" -label (uiRes("m_dagMenuProc.kDagMenuUseColorRamp")) useColorFeedbackCB`;

			$paintModeParent = `menuItem -subMenu true -label (uiRes("m_dagMenuProc.kDagMenuPaintMode")) $parent`;
								menuItem -label (uiRes("m_dagMenuProc.kDagMenuPaintModeAdd")) -c "artAttrPaintOperation artAttrSkinPaintCtx Add;" $paintModeParent;
								menuItem -label (uiRes("m_dagMenuProc.kDagMenuPaintModeReplace")) -c "artAttrPaintOperation artAttrSkinPaintCtx Replace;" $paintModeParent;
								menuItem -label (uiRes("m_dagMenuProc.kDagMenuPaintModeScale")) -c "artAttrPaintOperation artAttrSkinPaintCtx Scale;" $paintModeParent;
								menuItem -label (uiRes("m_dagMenuProc.kDagMenuPaintModeSmooth")) -c "artAttrPaintOperation artAttrSkinPaintCtx Smooth;" $paintModeParent;
			
			setParent -m $parent;
								
													
			$brushParent = `menuItem -subMenu true -label (uiRes("m_dagMenuProc.kDagMenuBrushProfile")) $parent`;
								menuItem -label (uiRes("m_dagMenuProc.kDagMenuBrushProfileHard")) $brushParent;
								menuItem -label (uiRes("m_dagMenuProc.kDagMenuBrushProfileSoft")) $brushParent;
								menuItem -label (uiRes("m_dagMenuProc.kDagMenuBrushProfileGaussian")) $brushParent;
					
			setParent -m $parent;																			
			
			$valueParent = `menuItem -subMenu true -label (uiRes("m_dagMenuProc.kDagMenuBrushValue")) $parent`;
								menuItem -label (uiRes("m_dagMenuProc.kDagMenuBrushValue0")) -c "artSkinSetSelectionValue 0.000 false artAttrSkinPaintCtx artAttrSkin;" $valueParent;
								menuItem -label (uiRes("m_dagMenuProc.kDagMenuBrushValue1")) -c "artSkinSetSelectionValue 0.100 false artAttrSkinPaintCtx artAttrSkin;"  $valueParent;
								menuItem -label (uiRes("m_dagMenuProc.kDagMenuBrushValue2")) -c "artSkinSetSelectionValue 0.200 false artAttrSkinPaintCtx artAttrSkin;"  $valueParent;
								menuItem -label (uiRes("m_dagMenuProc.kDagMenuBrushValue3")) -c "artSkinSetSelectionValue 0.300 false artAttrSkinPaintCtx artAttrSkin;"  $valueParent;
								menuItem -label (uiRes("m_dagMenuProc.kDagMenuBrushValue4")) -c "artSkinSetSelectionValue 0.400 false artAttrSkinPaintCtx artAttrSkin;"  $valueParent;
								menuItem -label (uiRes("m_dagMenuProc.kDagMenuBrushValue5")) -c "artSkinSetSelectionValue 0.500 false artAttrSkinPaintCtx artAttrSkin;"  $valueParent;
								menuItem -label (uiRes("m_dagMenuProc.kDagMenuBrushValue6")) -c "artSkinSetSelectionValue 0.600 false artAttrSkinPaintCtx artAttrSkin;"  $valueParent;
								menuItem -label (uiRes("m_dagMenuProc.kDagMenuBrushValue7")) -c "artSkinSetSelectionValue 0.700 false artAttrSkinPaintCtx artAttrSkin;"  $valueParent;
								menuItem -label (uiRes("m_dagMenuProc.kDagMenuBrushValue8")) -c "artSkinSetSelectionValue 0.800 false artAttrSkinPaintCtx artAttrSkin;"  $valueParent;
								menuItem -label (uiRes("m_dagMenuProc.kDagMenuBrushValue9")) -c "artSkinSetSelectionValue 0.900 false artAttrSkinPaintCtx artAttrSkin;"  $valueParent;
								menuItem -label (uiRes("m_dagMenuProc.kDagMenuBrushValue10")) -c "artSkinSetSelectionValue 1.000 false artAttrSkinPaintCtx artAttrSkin;"  $valueParent;		
								
			setParent -m $parent;																					
													
			$opacityParent = `menuItem -subMenu true -label (uiRes("m_dagMenuProc.kDagMenuOpacity")) $parent`;
								menuItem -label (uiRes("m_dagMenuProc.kDagMenuOpacityValue0")) -c "artAttrSkinPaintCtx -e -opacity 0.000 `currentCtx`" $opacityParent;
								menuItem -label (uiRes("m_dagMenuProc.kDagMenuOpacityValue1")) -c "artAttrSkinPaintCtx -e -opacity 0.100 `currentCtx`"  $opacityParent;
								menuItem -label (uiRes("m_dagMenuProc.kDagMenuOpacityValue2")) -c "artAttrSkinPaintCtx -e -opacity 0.200 `currentCtx`"  $opacityParent;
								menuItem -label (uiRes("m_dagMenuProc.kDagMenuOpacityValue3")) -c "artAttrSkinPaintCtx -e -opacity 0.300 `currentCtx`"  $opacityParent;
								menuItem -label (uiRes("m_dagMenuProc.kDagMenuOpacityValue4")) -c "artAttrSkinPaintCtx -e -opacity 0.400 `currentCtx`"  $opacityParent;
								menuItem -label (uiRes("m_dagMenuProc.kDagMenuOpacityValue5")) -c "artAttrSkinPaintCtx -e -opacity 0.500 `currentCtx`"  $opacityParent;
								menuItem -label (uiRes("m_dagMenuProc.kDagMenuOpacityValue6")) -c "artAttrSkinPaintCtx -e -opacity 0.600 `currentCtx`"  $opacityParent;
								menuItem -label (uiRes("m_dagMenuProc.kDagMenuOpacityValue7")) -c "artAttrSkinPaintCtx -e -opacity 0.650 `currentCtx`"  $opacityParent;
								menuItem -label (uiRes("m_dagMenuProc.kDagMenuOpacityValue8")) -c "artAttrSkinPaintCtx -e -opacity 0.750 `currentCtx`"  $opacityParent;
								menuItem -label (uiRes("m_dagMenuProc.kDagMenuOpacityValue9")) -c "artAttrSkinPaintCtx -e -opacity 0.850 `currentCtx`"  $opacityParent;
								menuItem -label (uiRes("m_dagMenuProc.kDagMenuOpacityValue10")) -c "artAttrSkinPaintCtx -e -opacity 1.000 `currentCtx`"  $opacityParent;							
			
			setParent -m $parent;					
								
			menuItem -divider true;
			menuItem -divider true;				
								
			$mirrorWeightsParent = `menuItem -subMenu false -c "MirrorSkinWeights" -label (uiRes("m_dagMenuProc.kDagMenuMirrorSkinWeights"))`;
			$mirroWeightsOB = `menuItem -subMenu false -ob true -c "MirrorSkinWeightsOptions" $mirrorWeightsParent`;
			
			$copyWeightsParent = `menuItem -subMenu false -c "CopySkinWeights" -label (uiRes("m_dagMenuProc.kDagMenuCopySkinWeights"))`;
			$copyWeightsOB = `menuItem -subMenu false -ob true -c "CopySkinWeightsOptions" $copyWeightsParent`;
			
			$pruneWeightsParent = `menuItem -subMenu false -c "PruneSmallWeights" -label (uiRes("m_dagMenuProc.kDagMenuPruneSmallWeights"))`;
			$pruneWeightsOB = `menuItem -subMenu false -ob true -c "PruneSmallWeightsOptions" $pruneWeightsParent`;			
			
			menuItem -subMenu false -c "removeUnusedInfluences" -label (uiRes("m_dagMenuProc.kDagMenuRemoveUnusedInfluences"));
			
			
			menuItem -divider true;
			menuItem -divider true;
			
			string $menu = `menuItem -subMenu true -aob true -label (uiRes("m_dagMenuProc.kDagMenuInputs")) `;
							menu -e 
								-pmc ( "createHistoryMenuItems \""+$menu+"\" "+$object ) $menu;
			setParent -m $parent;

			$menu = `menuItem -subMenu true -aob true -label (uiRes("m_dagMenuProc.kDagMenuOutputs")) `;
					menu -e -pmc ( "createFutureMenuItems \""+$menu+"\" "+$object ) $menu;
			setParent -m $parent;
			
			menuItem -divider true;
			menuItem -divider true;							
		}
		else
		{

		    // label the object
		    string $shortName = `substitute ".*|" $object ""`;
		    menuItem -label ($shortName + "...") -c ("showEditor "+$object);
		    menuItem -divider true;
		    menuItem -divider true;

		    // Create the list of selection masks
		    createSelectMenuItems($parent, $object);

		    menuItem -d true;

		    menuItem -label (uiRes("m_dagMenuProc.kSelect"))  -c ("select -r " + $object);
		    menuItem -label (uiRes("m_dagMenuProc.kSelectHierarchy"))  -c ("select -hierarchy " + $object);
		    string $container = `container -q -fc $object`;
		    if( $container != "" ){
			    menuItem -label (uiRes("m_dagMenuProc.kSelectContainer")) -c ("select -r " + $container);
		    }

    	    menuItem -d true;

		    optionalDagMenuProc( $parent, $object );

		    // Create the dg traversal menu
		    //
		    string $menu = `menuItem -subMenu true -aob true -label (uiRes("m_dagMenuProc.kDGTraversal")) `;
		    menu -e 
			    -pmc ( "createTraversalMenuItems \""+$menu+"\" "+$object ) $menu;
		    setParent -m $parent;

		    // create the history menu
		    //
		    string $menu = `menuItem -subMenu true -aob true -label (uiRes("m_dagMenuProc.kInputs")) `;
		    menu -e 
			    -pmc ( "createHistoryMenuItems \""+$menu+"\" "+$object ) $menu;
		    setParent -m $parent;

		    $menu = `menuItem -subMenu true -aob true -label (uiRes("m_dagMenuProc.kOutputs")) `;
		    menu -e -pmc ( "createFutureMenuItems \""+$menu+"\" "+$object ) $menu;
		    setParent -m $parent;

	 	    // Look at the shape child of this object
	 	    //
 		    string $shapes[] = `listRelatives -path -s $object`;

		    // get current selection of shapes
		    string $currentSel[] = `ls -sl -dagObjects -shapes` ;

		    string $paintParent = "" ;
		    int $selIndex  ;

 		    int $i;
 		    for ($i = 0; $i < size($shapes); ++$i) 
		    {
			    string $nodeType = `nodeType $shapes[$i]` ;

			    if ( ( $nodeType == "nurbsSurface") ||
				     ( $nodeType == "mesh") ||
				     ( $nodeType == "subdiv")) 
			    {
				    // save the object name if it is not already selected by the user
				    // We use this info to select the object if user chooses a paint option
				    //
				    // If user has selected multiple objects and is using context menu on one of them
				    // we do not change the selection list as user may want to paint some attribute 
				    // on all of them. (It is the way it has been working all along...we don't want to 
				    // break it )
    				
				    int $found = 0 ;
				    for( $selIndex  = 0 ; $selIndex  < size( $currentSel ); ++$selIndex  )
				    {
					    if( $shapes[$i] == $currentSel[ $selIndex  ] )
					    {
						    $found = 1 ;
						    break ;
					    }
				    }
    				
				    if( $found )
				    {
					    $artSelectObject = "" ;
				    }
				    else
				    {
					    // check if the object is in component selection mode
					    // and if it is, do not do any further selection.
					    // We are assuming that if the object is in hilite mode
					    // then the user is in component selection mode.
    					
					    $currentSel = `ls -hilite` ;
					    for( $selIndex  = 0 ; $selIndex  < size( $currentSel ); ++$selIndex  )
					    {
						    if( $object == $currentSel[ $selIndex  ] )
						    {
							    $found = 1 ;
							    break ;
						    }
					    }

					    if( !$found ) 
						    $artSelectObject = $object ;
					    else
						    $artSelectObject = "" ;
				    }
    				
				    $paintParent = `menuItem -subMenu true -aob true -label (uiRes("m_dagMenuProc.kPaintSubmenu")) `;
				    menu -e	-pmc ( "createArtAttrMenuItems \""+ $paintParent +"\" "+$object ) $paintParent ;
				    setParent -m $parent;
				    break ;
			    }
		    }

	        $menu = `menuItem -subMenu true -label (uiRes("m_dagMenuProc.kActions")) `;
		    menu -e -pmc ( "createActionsMenuItems \""+$menu+"\" "+$object ) $menu;

		    setParent -m $parent;

		    // If the object can handle uv sets then add the uvset menu
		    //
		    string $shape = objectHandlesUvSets( $object );
		    if ($shape != "")
		    {
			    $menu = `menuItem -subMenu true -label (uiRes("m_dagMenuProc.kUVSets")) `;
			    menu -e 
				    -pmc ( "createUVsetMenuItems \""+$menu+"\" " +$object + " "+ $shape )
				    $menu;
			    setParent -m $parent;
		    }

		    string $shape = objectHandlesColorSets( $object );
		    if ($shape != "")
		    {
			    $menu = `menuItem -subMenu true -label (uiRes("m_dagMenuProc.kColorSets")) `;
			    menu -e 
				    -pmc ( "createColorSetMenuItems \""+$menu+"\" " +$object + " "+ $shape )
				    $menu;
			    setParent -m $parent;
		    }

		    // Shader menu to be able to quickly assign existing shaders
		    // to the object under the pointer.
		    //
    	    menuItem -d true;

 		    menuItem -label (uiRes("m_dagMenuProc.kMaterialAttributes")) -c ("showSG "+$object);
        	
    	    menuItem -d true;
            
            buildShaderMenus($object);
            
            menuItem -d true;

            menuItem -divider true;

            string $removeOverrideMenuItem = `menuItem 
			    -label (uiRes("m_dagMenuProc.kRemoveMaterialOverride"))
                -subMenu true`;
            menuItem -edit -postMenuCommand
                ("buildMaterialRemoveOverrideMenu -surface "+$object+" "+$removeOverrideMenuItem)
                $removeOverrideMenuItem;
            setParent -m ..;

		    int $mentalIsLoaded = 0;
		    string $renderer;
	        for ($renderer in `renderer -query -namesOfAvailableRenderers`) {
			    if( $renderer == "mentalRay" ) {
				    $mentalIsLoaded = 1;
				    break;
			    }
		    }

		    if ($mentalIsLoaded) {
 			    $menu = `menuItem -subMenu true -label (uiRes("m_dagMenuProc.kBaking")) `;
 			    menu -e
				    -pmc ( "createBakingMenuItems \""+$menu+"\" "+$object )
				    $menu;
 			    setParent -m $parent;
		    }

    //		{
    // 			$menu = `menuItem -subMenu true -label $paint `;
    //			menu -e
    //				-pmc ( "createPaintingMenuItems \""+$menu+"\" "+$object )
    //				$menu;
    // 			setParent -m $parent;
    //		}

		    if ($mode == "dynamicsMenuSet") {
			    menuItem -d true;
			    menuItem -label (uiRes("m_dagMenuProc.kConnectField"))  -c ("connectDynamic -f " + $object);
			    menuItem -label (uiRes("m_dagMenuProc.kConnectEmitter"))  -c ("connectDynamic -em " + $object);
			    menuItem -label (uiRes("m_dagMenuProc.kConnectCollision"))  -c ("connectDynamic -c " + $object);
		    }

		    // is there a reference associated with the object ?
		    // and if so, is it in a loaded or unloaded state?
		    string $refNode = `getRelatedReference $object`;
		    if( size($refNode) > 0) {
			    menuItem -d true;
			    if( `file -rfn $refNode -q -dr` ) {
				    menuItem -label (uiRes("m_dagMenuProc.kLoadRelatedReference"))  -c ("loadRelatedReference " + $object);
			    } else {
				    menuItem -label (uiRes("m_dagMenuProc.kReloadRelatedReference"))  -c ("loadRelatedReference " + $object);
				    menuItem -label (uiRes("m_dagMenuProc.kUnloadRelatedReference"))  -c ("unloadRelatedReference " + $object);
			    }
			    // Is this reference a proxy? If so, add proxy switch submenu
			    //
			    string $proxyNodes[] = `getRelatedProxies $refNode`;
			    if(size($proxyNodes) > 0) {
				    $menu = `menuItem -subMenu true -label (uiRes("m_dagMenuProc.kReloadProxy")) `;
				    menu -e
					    -pmc ( "createSwitchProxyMenuItems \""+$menu+"\" "+$object + " " + $refNode )
					    $menu;
				    setParent -m $parent;
			    }
		    }

			// map: add "View Last Rendered Shadow Map" menu item
			setParent -m $parent;
			for ($i = 0; $i < size($shapes); ++$i)
			{
				string $nodeType = `nodeType $shapes[$i]` ;
				if ($nodeType == "dl_uberLightShape")
				{
					menuItem -d true;
					menuItem -l "View Last Rendered Shadow Map" -c ("dl_ViewLastShadowMap(\"" + $shapes[0] + "\")") -en (`dl_SetShadowMenuItemState($shapes[0])`);
					setParent -m $parent;
				}
			}
			
		    string $container = `container -q -findContainer { $object }`;
    		
		    if (size($container) > 0)
		    {
			    string $menuProc = `getAttr ($container+".rmbCommand")`;
			    if (size($menuProc) > 0)
			    {
				    if (`exists $menuProc`)
				    {
					    string $menuItems[] = `eval $menuProc`;
					    int $mm;
					    int $menuCount = size($menuItems);
					    if ($menuCount % 2 != 0)
					    {
						    // the user provided an invalid # of items, skip
						    // the last
						    //
						    $menuCount--;
					    }
					    if ($menuCount > 0) {
						    string $containerType = `getAttr ($container + ".containerType")`;
						    if ($containerType == "")
						    {
							    menuItem -d true;
							    menuItem - subMenu true -label (uiRes("m_dagMenuProc.kCustom"));
						    }
						    else
						    {
							    menuItem -d true;
							    menuItem -subMenu true -label ($containerType);
						    }
						    for ($mm = 0; $mm < $menuCount; $mm+=2)
						    {
							    menuItem -label $menuItems[$mm] -c ($menuItems[$mm+1]+" "+$object);
						    }
					    }
				    }
				    else {
					    string $warnStr = (uiRes("m_dagMenuProc.kSkippedRmb"));
					    warning(`format -s $menuProc $warnStr`);
				    }
			    }
		    }

		    setParent -m $parent;

        }
	} else {
		string $warn = (uiRes("m_dagMenuProc.kMenuWarn"));
		warning(`format -s $parent $warn`);
	}
}

global proc dl_ViewLastShadowMap(string $node)
{
//	string $ws = `workspace -q -dir`;
	string $ws = `pwd`;  $ws += "/";
	$ws = substituteAllString($ws, "/scenes/", "/");
	string $scene = `file -q -sn`;
	if ($scene == "")
		$scene = "untitled";
	$scene = basenameEx($scene);
	string $lightConn[] = `connectionInfo -dfs ($node + ".instObjGroups[0]")`;
	string $temp[];
	tokenize($lightConn[0], ".", $temp);
	string $delightSetConn = `connectionInfo -sfd ($temp[0] + ".lightAttribs")`;
	clear $temp;
	tokenize($delightSetConn, ".", $temp);
	string $pathAttr = `getAttr ($temp[0] + ".shadowMapName")`;
	$pathAttr = substituteAllString($pathAttr, "<scene>", $scene);
	$pathAttr = substituteAllString($pathAttr, "depthmap<shape_name>_#.shw", "");
	string $path = $ws + $pathAttr;
	string $shapeName = substituteAllString($node, "_", "__");
	string $dirContent = `system("ls -c " + $path + " | grep " + $shapeName)`;
	string $images[];
	tokenize($dirContent, "\n", $images);
	string $matchString = substituteAllString($node, "_", "*");
	if (gmatch($images[0], ("*" + $matchString + "*")))
		system("i-display " + $path + $images[0] + "&");
}

global proc int dl_SetShadowMenuItemState(string $node)
{
//	string $ws = `workspace -q -dir`;
	string $ws = `pwd`; $ws += "/";
	$ws = substituteAllString($ws, "/scenes/", "/");
	string $scene = `file -q -sn`;
	if ($scene == "")
		$scene = "untitled";
	$scene = basenameEx($scene);
	string $lightConn[] = `connectionInfo -dfs ($node + ".instObjGroups[0]")`;
	if (size($lightConn[0]) == 0)
		return 0;
	else
	{
		string $temp[];
		tokenize($lightConn[0], ".", $temp);
		string $delightSetConn = `connectionInfo -sfd ($temp[0] + ".lightAttribs")`;
		clear $temp;
		tokenize($delightSetConn, ".", $temp);
		string $pathAttr = `getAttr ($temp[0] + ".shadowMapName")`;
		$pathAttr = substituteAllString($pathAttr, "<scene>", $scene);
		$pathAttr = substituteAllString($pathAttr, "depthmap<shape_name>_#.shw", "");
		string $path = $ws + $pathAttr;
		string $tmp[];
		string $check = `system("[ -a " + $path + " ] || echo \"NA\"")`;
		tokenize($check, "\n", $tmp);
		if ($tmp[0] == "NA")
		{
			return 0;
		}
		string $shapeName = substituteAllString($node, "_", "__");
		string $dirContent = `system("ls -c " + $path + " | grep " + $shapeName)`;
		string $images[];
		tokenize($dirContent, "\n", $images);
		string $matchString = substituteAllString($node, "_", "*");
		if (gmatch($images[0], ("*" + $matchString + "*")))
			return 1;
		else
			return 0;
	}
}
